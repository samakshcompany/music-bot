/**
 * Lock type enumeration
 */
export declare enum LockType {
    READ = "read",
    WRITE = "write"
}
/**
 * Lock request interface
 */
export interface LockRequest {
    type: LockType;
    resolve: () => void;
    reject: (error: Error) => void;
    timeout?: number;
    timeoutId?: NodeJS.Timeout;
}
/**
 * ReadWriteLock implementation with high-performance optimizations
 * Features fast path for uncontended locks and object pooling
 */
export declare class ReadWriteLock {
    private readers;
    private writer;
    private queue;
    private maxReaders;
    private readReleasePool;
    private writeReleasePool;
    private requestPool;
    /**
     * Acquire a read lock with fast path optimization
     * @param timeout Optional timeout in milliseconds
     * @returns Promise that resolves when lock is acquired, or synchronous result for fast path
     */
    readLock(timeout?: number): Promise<() => void>;
    /**
     * Acquire a write lock with fast path optimization
     * @param timeout Optional timeout in milliseconds
     * @returns Promise that resolves when lock is acquired, or synchronous result for fast path
     */
    writeLock(timeout?: number): Promise<() => void>;
    /**
     * Get a pooled read release function
     */
    private getPooledReadRelease;
    /**
     * Get a pooled write release function
     */
    private getPooledWriteRelease;
    /**
     * Get a pooled request object
     */
    private getPooledRequest;
    /**
     * Return a request object to the pool
     */
    private returnRequestToPool;
    /**
     * Process the lock request queue with optimizations
     */
    private processQueue;
    /**
     * Check if a lock request can be granted
     */
    private canGrantLock;
    /**
     * Remove a request from the queue (used for timeout cleanup)
     */
    private removeFromQueue;
    /**
     * Get current lock status for debugging
     */
    getStatus(): {
        readers: number;
        writer: boolean;
        queueLength: number;
    };
    /**
     * Set maximum number of concurrent readers
     */
    setMaxReaders(max: number): void;
    /**
     * Clean up all pending timeouts and clear pools (useful for shutdown)
     */
    cleanup(): void;
    /**
     * Get performance statistics
     */
    getPerformanceStats(): {
        readers: number;
        writer: boolean;
        queueLength: number;
        poolSizes: {
            readRelease: number;
            writeRelease: number;
            requests: number;
        };
    };
}
